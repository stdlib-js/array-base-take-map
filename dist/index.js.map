{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/assign.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar resolveGetter = require( '@stdlib/array-base-resolve-getter' );\nvar ind = require( '@stdlib/ndarray-base-ind' ).factory;\n\n\n// MAIN //\n\n/**\n* Takes elements from an array, applies a mapping function using a callback, and returns a new array.\n*\n* @param {Collection} x - input array\n* @param {IntegerArray} indices - list of indices\n* @param {string} mode - index mode\n* @param {Function} clbk - callback to invoke\n* @returns {Array} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n* var indices = [ 3, 1, 2, 0 ];\n*\n* function clbk(val){\n\treturn 2 * val;\n}\n*\n* var y = takeMap( x, indices, 'throw' ,clbk );\n* // returns [ 8, 4, 6, 2 ]\n*/\nfunction takeMap( x, indices, mode, clbk ) {\n\tvar getIndex;\n\tvar xget;\n\tvar iget;\n\tvar out;\n\tvar max;\n\tvar i;\n\tvar j;\n\n\t// Resolve an accessor for retrieving array elements:\n\txget = resolveGetter( x );\n\tiget = resolveGetter( indices );\n\n\t// Resolve a function for returning an index according to the specified index mode:\n\tgetIndex = ind( mode );\n\n\t// Resolve the maximum index:\n\tmax = x.length - 1;\n\n\t// Extract each desired element from the provided array...\n\tout = [];\n\tfor ( i = 0; i < indices.length; i++ ) {\n\t\tj = getIndex( iget( indices, i ), max );\n\n\t\t// eslint-disable-next-line no-useless-call\n\t\tout.push( clbk.call( null, xget( x, j ), j ) ); // use `Array#push` to ensure \"fast\" elements\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = takeMap;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isComplexDataType = require( '@stdlib/array-base-assert-is-complex-floating-point-data-type' );\nvar arraylike2object = require( '@stdlib/array-base-arraylike2object' );\nvar reinterpret = require( '@stdlib/strided-base-reinterpret-complex' );\nvar ind = require( '@stdlib/ndarray-base-ind' ).factory;\n\n\n// FUNCTIONS //\n\n/**\n* Takes elements from an indexed array and assigns the values to elements in an indexed output array.\n*\n* @private\n* @param {Collection} x - input array.\n* @param {IntegerArray} indices - list of indices.\n* @param {string} mode - index mode.\n* @param {Collection} out - output array.\n* @param {integer} stride - output array stride.\n* @param {NonNegativeInteger} offset - output array offset.\n* @param {Function} clbk - callback function applied to each selected element.\n* @returns {Collection} output array.\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n* var indices = [ 3, 1, 2, 0 ];\n* var out = [ 0, 0, 0, 0 ];\n*\n* function clbk( val ){\n\treturn val;\n}\n*\n* var arr = takeMapIndexed( x, indices, 'throw', out, 1, 0, clbk );\n* // returns [ 4, 2, 3, 1 ]\n*/\nfunction takeMapIndexed( x, indices, mode, out, stride, offset, clbk ) {\n\tvar getIndex;\n\tvar max;\n\tvar io;\n\tvar i;\n\tvar j;\n\n\t// Resolve a function for returning an index according to the specified index mode:\n\tgetIndex = ind( mode );\n\n\t// Resolve the maximum index:\n\tmax = x.length - 1;\n\n\t// Extract each desired element from the provided array...\n\tio = offset;\n\tfor ( i = 0; i < indices.length; i++ ) {\n\t\tj = getIndex( indices[ i ], max );\n\t\tout[ io ] = x[ j ];\n\t\tio += stride;\n\t}\n\tfor (i = 0; i<out.length; i++) {\n\t\t// eslint-disable-next-line no-useless-call\n\t\tout[i] = clbk.call( null, out[i], i );\n\t}\n\treturn out;\n}\n\n/**\n* Takes elements from an accessor array and assigns the values to elements in an accessor output array.\n*\n* @private\n* @param {Object} x - input array object.\n* @param {Object} indices - index array object.\n* @param {string} mode - index mode.\n* @param {Object} out - output array object.\n* @param {integer} stride - output array stride.\n* @param {NonNegativeInteger} offset - Output array offset.\n* @param {Function} clbk - callback function applied to each selected element.\n* @returns {Collection} output array.\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var arraylike2object = require( '@stdlib/array-base-arraylike2object' );\n*\n* var x = toAccessorArray( [ 1, 2, 3, 4 ] );\n* var indices = toAccessorArray( [ 3, 1, 2, 0 ] );\n*\n* function clbk(val){\n\treturn val+1;\n}\n*\n* var out = toAccessorArray( [ 0, 0, 0, 0 ] );\n* var arr = accessorsMap( arraylike2object( x ), arraylike2object( indices ), 'throw', arraylike2object( out ), 1, 0, clbk );\n* // [ 4, 2, 3, 1 ]\n*/\nfunction accessorsMap( x, indices, mode, out, stride, offset, clbk ) {\n\tvar getIndex;\n\tvar xdata;\n\tvar idata;\n\tvar odata;\n\tvar xget;\n\tvar iget;\n\tvar oset;\n\tvar max;\n\tvar io;\n\tvar i;\n\tvar j;\n\n\txdata = x.data;\n\tidata = indices.data;\n\todata = out.data;\n\n\txget = x.accessors[ 0 ];\n\tiget = indices.accessors[ 0 ];\n\toset = out.accessors[ 1 ];\n\n\t// Resolve a function for returning an index according to the specified index mode:\n\tgetIndex = ind( mode );\n\n\t// Resolve the maximum index:\n\tmax = xdata.length - 1;\n\n\t// Extract each desired element from the provided array...\n\tio = offset;\n\tfor (i = 0; i < idata.length; i++) {\n\t\tj = getIndex( iget( idata, i ), max );\n\n\t\t// eslint-disable-next-line no-useless-call\n\t\toset( odata, io, clbk.call( null, xget( xdata, j ), j ) );\n\t\tio += stride;\n\t}\n\treturn odata;\n}\n\n/**\n* Takes elements from a complex array and assigns the values to elements in a complex output array.\n*\n* @private\n* @param {Collection} x - real-valued floating-point input array view\n* @param {Object} indices - index array object\n* @param {string} mode - index mode\n* @param {Collection} out - real-valued floating-point output array view\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @param {Function} clbk - callback function applied to each selected element\n* @returns {Collection} output array view\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var arraylike2object = require( '@stdlib/array-base-arraylike2object' );\n*\n* var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var indices = [ 0, 0, 1, 1 ];\n*\n* var out = new Float64Array( 8 );\n*\n* function clbk(val){\n\treturn val;\n}\n*\n* var arr = complexMap( x, arraylike2object( indices ), 'throw', out, 1, 0, clbk );\n* // returns <Float64Array>[ 1.0, 2.0, 1.0, 2.0, 3.0, 4.0, 3.0, 4.0 ]\n*/\nfunction complexMap( x, indices, mode, out, stride, offset, clbk ) {\n\tvar getIndex;\n\tvar idata;\n\tvar iget;\n\tvar max;\n\tvar io;\n\tvar so;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\tidata = indices.data;\n\tiget = indices.accessors[ 0 ];\n\n\t// Resolve a function for returning an index according to the specified index mode:\n\tgetIndex = ind( mode );\n\n\t// Resolve the maximum index:\n\tmax = ( x.length/2 ) - 1; // resolve the length of the original complex array\n\n\t// Extract each desired element from the provided array...\n\tso = stride * 2; // note: multiply by 2, as real-valued array consists of interleaved real and imaginary components\n\tio = offset * 2;\n\tfor ( i = 0; i < idata.length; i++ ) {\n\t\tj = getIndex( iget( idata, i ), max );\n\t\tk = j * 2;\n\n\t\t// eslint-disable-next-line no-useless-call\n\t\tout[ io ] = clbk.call( null, x[ k ], k );\n\n\t\t// eslint-disable-next-line no-useless-call\n\t\tout[ io+1 ] = clbk.call( null, x[ k+1 ], k+1 );\n\t\tio += so;\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Takes elements from an array and assigns the values to elements in a provided output array.\n*\n* @param {Collection} x - input array.\n* @param {IntegerArray} indices - list of indices.\n* @param {string} mode - index mode.\n* @param {Collection} out - output array.\n* @param {integer} stride - output array stride.\n* @param {NonNegativeInteger} offset - output array offset.\n* @param {Function} clbk - callback function applied to each selected element.\n* @returns {Collection} output array.\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n* var indices = [ 3, 1, 2, 0 ];\n*\n* var out = [ 0, 0, 0, 0 ];\n*\n* function clbk( val ){\n\treturn val;\n}\n* var arr = assignMap( x, indices, 'throw', out, 1, 0, clbk);\n* // arr is [ 4, 2, 3, 1 ]\n*\n* var bool = ( arr === out );\n* // bool is true\n*/\nfunction assignMap( x, indices, mode, out, stride, offset, clbk ) {\n\tvar xo;\n\tvar io;\n\tvar oo;\n\n\txo = arraylike2object( x );\n\tio = arraylike2object( indices );\n\too = arraylike2object( out );\n\tif (\n\t\txo.accessorProtocol ||\n\t\tio.accessorProtocol ||\n\t\too.accessorProtocol\n\t) {\n\t\t// Note: we only explicitly support complex-to-complex, as this function should not be concerned with casting rules, etc. That is left to userland...\n\t\tif (\n\t\t\tisComplexDataType( xo.dtype ) &&\n\t\t\tisComplexDataType( oo.dtype )\n\t\t) {\n\t\t\tcomplexMap( reinterpret( x, 0 ), io, mode, reinterpret( out, 0 ), stride, offset, clbk ); // eslint-disable-line max-len\n\t\t\treturn out;\n\t\t}\n\t\taccessorsMap( xo, io, mode, oo, stride, offset, clbk );\n\t\treturn out;\n\t}\n\ttakeMapIndexed( x, indices, mode, out, stride, offset, clbk );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = assignMap;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Take elements from an array and apply a provided function to map values.\n*\n* @module @stdlib/array-base-take-map\n*\n* @example\n* var takeMap = require( '@stdlib/array-base-take-map' );\n*\n* var x = [ 1, 2, 3, 4 ];\n*\n* function mapFunction( val ) {\n    return val;\n}\n*\n* var indices = [ 0, 0, 1, 1, 3, 3 ];\n* var y = takeMap( x, indices, 'throw', mapFunction );\n* // returns [ 1, 1, 2, 2, 4, 4 ]\n*\n* @example\n* var takeMap = require( '@stdlib/array-base-take-map' );\n*\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = [ 0, 0, 0, 0, 0, 0 ];\n* var indices = [ 0, 0, 1, 1, 3, 3 ];\n*\n* function clbk( val ) {\n    return val;\n}\n*\n* var arr = takeMap.assign( x, indices, 'throw', out, 1, 0, mapFunction );\n* // returns [ 1, 1, 2, 2, 4, 4 ]\n*\n* var bool = ( arr === out );\n* // returns true\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar main = require( './main.js' );\nvar assign = require( './assign.js' );\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_main", "__commonJSMin", "exports", "module", "resolveGetter", "ind", "takeMap", "x", "indices", "mode", "clbk", "getIndex", "xget", "iget", "out", "max", "i", "j", "require_assign", "__commonJSMin", "exports", "module", "isComplexDataType", "arraylike2object", "reinterpret", "ind", "takeMapIndexed", "x", "indices", "mode", "out", "stride", "offset", "clbk", "getIndex", "max", "io", "i", "j", "accessorsMap", "xdata", "idata", "odata", "xget", "iget", "oset", "complexMap", "so", "k", "assignMap", "xo", "oo", "setReadOnly", "main", "assign"]
}
